From: Nick Piggin <npiggin@suse.de>
Subject: [patch 5/9] mm: lockless probe

Probing pages and radix_tree_tagged are lockless operations with the
lockless radix-tree. Convert these users to RCU locking rather than
using tree_lock.

Signed-off-by: Nick Piggin <npiggin@suse.de>

---
 mm/page-writeback.c |    8 +++-----
 mm/readahead.c      |    6 ++----
 2 files changed, 5 insertions(+), 9 deletions(-)

Index: linux-2.6.23-rt1/mm/page-writeback.c
===================================================================
--- linux-2.6.23-rt1.orig/mm/page-writeback.c	2007-10-11 15:57:32.000000000 -0400
+++ linux-2.6.23-rt1/mm/page-writeback.c	2007-10-11 16:01:06.000000000 -0400
@@ -1022,17 +1022,15 @@ int test_set_page_writeback(struct page 
 EXPORT_SYMBOL(test_set_page_writeback);
 
 /*
- * Return true if any of the pages in the mapping are marged with the
+ * Return true if any of the pages in the mapping are marked with the
  * passed tag.
  */
 int mapping_tagged(struct address_space *mapping, int tag)
 {
-	unsigned long flags;
 	int ret;
-
-	read_lock_irqsave(&mapping->tree_lock, flags);
+	rcu_read_lock();
 	ret = radix_tree_tagged(&mapping->page_tree, tag);
-	read_unlock_irqrestore(&mapping->tree_lock, flags);
+	rcu_read_unlock();
 	return ret;
 }
 EXPORT_SYMBOL(mapping_tagged);
Index: linux-2.6.23-rt1/mm/readahead.c
===================================================================
--- linux-2.6.23-rt1.orig/mm/readahead.c	2007-10-11 15:57:32.000000000 -0400
+++ linux-2.6.23-rt1/mm/readahead.c	2007-10-11 16:01:06.000000000 -0400
@@ -156,20 +156,19 @@ __do_page_cache_readahead(struct address
 	/*
 	 * Preallocate as many pages as we will need.
 	 */
-	read_lock_irq(&mapping->tree_lock);
 	for (page_idx = 0; page_idx < nr_to_read; page_idx++) {
 		pgoff_t page_offset = offset + page_idx;
 
 		if (page_offset > end_index)
 			break;
 
+		rcu_read_lock();
 		page = radix_tree_lookup(&mapping->page_tree, page_offset);
+		rcu_read_unlock();
 		if (page)
 			continue;
 
-		read_unlock_irq(&mapping->tree_lock);
 		page = page_cache_alloc_cold(mapping);
-		read_lock_irq(&mapping->tree_lock);
 		if (!page)
 			break;
 		page->index = page_offset;
@@ -178,7 +177,6 @@ __do_page_cache_readahead(struct address
 			SetPageReadahead(page);
 		ret++;
 	}
-	read_unlock_irq(&mapping->tree_lock);
 
 	/*
 	 * Now start the IO.  We ignore I/O errors - if the page is not

From: Nick Piggin <npiggin@suse.de>
Subject: [patch 4/9] mm: __add_to_swap_cache stuff

__add_to_swap_cache unconditionally sets the page locked. Instead, just
ensure that the page is locked (which is a usual invariant for manipulating
swapcache).

Signed-off-by: Nick Piggin <npiggin@suse.de>

---
 mm/swap_state.c |    7 +++++--
 1 file changed, 5 insertions(+), 2 deletions(-)

Index: linux-2.6.23-rt1/mm/swap_state.c
===================================================================
--- linux-2.6.23-rt1.orig/mm/swap_state.c	2007-10-11 15:57:32.000000000 -0400
+++ linux-2.6.23-rt1/mm/swap_state.c	2007-10-11 16:01:06.000000000 -0400
@@ -74,6 +74,7 @@ static int __add_to_swap_cache(struct pa
 {
 	int error;
 
+	BUG_ON(!PageLocked(page));
 	BUG_ON(PageSwapCache(page));
 	BUG_ON(PagePrivate(page));
 	error = radix_tree_preload(gfp_mask);
@@ -83,7 +84,6 @@ static int __add_to_swap_cache(struct pa
 						entry.val, page);
 		if (!error) {
 			page_cache_get(page);
-			SetPageLocked(page);
 			SetPageSwapCache(page);
 			set_page_private(page, entry.val);
 			total_swapcache_pages++;
@@ -338,6 +338,7 @@ struct page *read_swap_cache_async(swp_e
 								vma, addr);
 			if (!new_page)
 				break;		/* Out of memory */
+			SetPageLocked(new_page);/* could be non-atomic op */
 		}
 
 		/*
@@ -361,7 +362,9 @@ struct page *read_swap_cache_async(swp_e
 		}
 	} while (err != -ENOENT && err != -ENOMEM);
 
-	if (new_page)
+	if (new_page) {
+		ClearPageLocked(new_page);
 		page_cache_release(new_page);
+	}
 	return found_page;
 }
